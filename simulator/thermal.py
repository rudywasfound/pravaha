"""
Thermal subsystem simulator for satellite.

This module models temperature dynamics for:
1. Solar panels (exposed to sun and space vacuum)
2. Battery (heated by charging/discharging inefficiency)
3. Payload electronics (heat generated by computation)
4. Bus current (proxy for power dissipation)

Thermal modeling is essential for realistic fault diagnosis because:
1. Many power subsystem faults manifest as thermal effects first
2. Temperature is slower to respond than voltage (thermal mass)
3. Thermal failure modes are different from electrical (e.g., heatsink failure)
4. Multi-fault scenarios show power-thermal coupling (solar loss -> battery stress -> overtemp)

The simulator supports realistic degradation modes:
- Insulation loss (radiator fouling, MLI damage)
- Heatsink failure (poor thermal contact, contamination)
- Thermal control system degradation (loop efficiency loss)

All parameters are tuned to match IRS-class satellite thermal architecture.
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple


@dataclass
class ThermalTelemetry:
    """
    Container for thermal subsystem telemetry outputs.
    
    Temperature data is particularly valuable because it responds differently
    than voltage to faults. For example, a battery aging fault:
    - Voltage: drops suddenly when charging begins
    - Temperature: rises gradually as internal resistance increases losses
    
    This temporal difference helps causal inference distinguish between causes.
    """
    
    time: np.ndarray              # Seconds elapsed
    battery_temp: np.ndarray      # Celsius (typically 0-60C operating range)
    solar_panel_temp: np.ndarray  # Celsius (can reach 80C+ in sun)
    payload_temp: np.ndarray      # Celsius (electronics thermal limits ~70C)
    bus_current: np.ndarray       # Amps (proxy for power dissipation)
    timestamp: np.ndarray         # Sample indices


class ThermalSimulator:
    """
    Realistic thermal subsystem simulator.
    
    Thermal systems are modeled as first-order systems with:
    dT/dt = (heat_in - heat_out) / thermal_mass
    
    This is simplified but captures the essential physics:
    1. Heat generation from inefficiency
    2. Heat dissipation through radiators
    3. Thermal mass damping rapid changes
    4. Degradation of cooling effectiveness
    """

    def __init__(
        self,
        duration_hours: float = 24,
        sampling_rate_hz: float = 0.1,
    ):
        """
        Initialize thermal simulator.
        
        Args:
            duration_hours: Mission duration
            sampling_rate_hz: Sampling frequency
        
        We use the same time parameters as power simulator to ensure
        time axis alignment when combining telemetry.
        """
        
        self.duration_hours = duration_hours
        self.sampling_rate_hz = sampling_rate_hz

        self.num_samples = int(duration_hours * 3600 * sampling_rate_hz)
        self.time = np.linspace(0, duration_hours * 3600, self.num_samples)
        self.dt = self.time[1] - self.time[0]

    def simulate_solar_panel_temp(
        self,
        base_temp: float = 45.0,
        eclipse_frequency_hours: float = 1.5,
        max_eclipse_temp: float = 5.0,
        degradation_start_hour: float = None,
        degradation_drift_rate: float = 0.5,
    ) -> np.ndarray:
        """
        Simulate solar panel temperature.

        Why panels have special thermal dynamics:
        1. Directly exposed to vacuum and sun radiation
        2. Vacuum cooling is very effective (radiative heat transfer)
        3. In eclipse, panels cool rapidly
        4. Temperature oscillates with orbital period (~90 minutes for IRS orbit)
        5. Insulation degradation prevents cooling (MLI damage, coating loss)

        Args:
            base_temp: Temperature in sunlight
            eclipse_frequency_hours: Orbital period
            max_eclipse_temp: Minimum temperature in eclipse
            degradation_start_hour: When insulation degrades
            degradation_drift_rate: How fast temperature rises after degradation (C/hour)

        Returns:
            solar_panel_temp: Temperature time series
        """
        
        # Model eclipse cycles with sinusoid oscillation
        # Amplitude represents sun vs eclipse difference
        orbital_phase = 2 * np.pi * self.time / (eclipse_frequency_hours * 3600)
        panel_temp = base_temp * (1 + 0.7 * np.cos(orbital_phase)) / 2 + max_eclipse_temp

        # Add orbital transients (quick changes when entering/leaving eclipse)
        # The 2x frequency represents two transitions per orbit
        panel_temp += 3 * np.sin(2 * orbital_phase) + np.random.normal(0, 1, len(panel_temp))

        # Inject insulation degradation (e.g., MLI tearing, coating damage)
        # This prevents radiative cooling, causing temperature drift
        if degradation_start_hour is not None:
            degrad_start_sample = int(degradation_start_hour * 3600 * self.sampling_rate_hz)
            degrad_start_sample = min(degrad_start_sample, len(self.time) - 1)
            if degrad_start_sample < len(self.time):
                # Time since degradation started (in hours)
                time_since_degrad = (self.time[degrad_start_sample:] - self.time[degrad_start_sample]) / 3600
                # Temperature drift accumulates linearly (worst case model)
                drift = degradation_drift_rate * time_since_degrad
                panel_temp[degrad_start_sample:] += drift

        return panel_temp

    def simulate_battery_temp(
        self,
        solar_input: np.ndarray,
        battery_charge: np.ndarray,
        base_temp: float = 30.0,
        max_temp: float = 60.0,
        power_dissipation_factor: float = 0.1,
        thermal_mass: float = 1000.0,
        ambient_temp: float = 20.0,
        heat_dissipation_rate: float = 0.05,
        degradation_start_hour: float = None,
        degradation_factor: float = 0.5,
    ) -> np.ndarray:
        """
        Simulate battery temperature.

        Why battery temperature matters:
        1. Heat is generated by I^2*R losses during charging/discharging
        2. Aggressive charging (high solar input) = more heat
        3. Battery aging from thermal cycling, which increases losses
        4. Heatsink failure reduces cooling, temperature spikes
        5. High temperature accelerates aging (feedback loop)

        Args:
            solar_input: Solar power input
            battery_charge: Battery state of charge
            base_temp: Nominal operating temperature
            max_temp: Maximum safe temperature
            power_dissipation_factor: Fraction of power lost as heat
            thermal_mass: Heat capacity (higher = slower response)
            ambient_temp: Space temperature
            heat_dissipation_rate: Radiator cooling effectiveness
            degradation_start_hour: When cooling fails
            degradation_factor: Remaining cooling after degradation

        Returns:
            battery_temp: Temperature time series
        """
        
        battery_temp = np.zeros(self.num_samples)
        temp = base_temp

        for i in range(self.num_samples):
            # Heat generation from charging/discharging inefficiency
            # More aggressive charging (high solar input) produces more heat
            # Low state of charge also stresses the battery (higher current)
            charge_stress = (1 - battery_charge[i] / 100.0) * (solar_input[i] / 500.0)
            heat_generation = power_dissipation_factor * charge_stress * 100

            # Cooling effectiveness from radiator
            cooling = heat_dissipation_rate
            
            # Degrade cooling if heatsink fails
            if degradation_start_hour is not None:
                degrad_start_sample = int(
                    degradation_start_hour * 3600 * self.sampling_rate_hz
                )
                if i >= degrad_start_sample:
                    cooling *= degradation_factor

            # Heat dissipation is proportional to temperature difference
            # (Newton's cooling law)
            temp_differential = temp - ambient_temp
            natural_cooling = cooling * temp_differential

            # Update temperature via first-order thermal model
            # Thermal mass (large capacitance) slows response
            temp_change = (heat_generation - natural_cooling) * self.dt / thermal_mass
            temp = np.clip(temp + temp_change, ambient_temp, max_temp)

            battery_temp[i] = temp

            # Add sensor noise (realistic measurement uncertainty)
            battery_temp[i] += np.random.normal(0, 0.3)

        return battery_temp

    def simulate_payload_temp(
        self,
        battery_voltage: np.ndarray,
        base_temp: float = 25.0,
        max_temp: float = 50.0,
        power_draw_factor: float = 0.05,
        degradation_start_hour: float = None,
        degradation_factor: float = 0.7,
    ) -> np.ndarray:
        """
        Simulate payload electronics temperature.

        Why payload temperature:
        1. Payload can only operate at full power if voltage is sufficient
        2. Low voltage limits operating frequency and power consumption
        3. This directly affects payload temperature
        4. Payload radiator failure prevents cooling
        5. Creates coupling between power subsystem and payload health

        Args:
            battery_voltage: Available bus voltage
            base_temp: Nominal payload temperature
            max_temp: Maximum operating temperature
            power_draw_factor: Heat generation per unit voltage
            degradation_start_hour: When thermal isolation fails
            degradation_factor: Remaining cooling effectiveness

        Returns:
            payload_temp: Temperature time series
        """
        
        payload_temp = np.zeros(self.num_samples)
        temp = base_temp

        for i in range(self.num_samples):
            # Heat generation correlates with available power
            # More available power = higher frequency operation = more heat
            available_power = battery_voltage[i]
            heat = power_draw_factor * available_power

            # Cooling rate from radiator
            cooling_rate = 0.03
            
            # Degrade cooling if radiator fails
            if degradation_start_hour is not None:
                degrad_start_sample = int(
                    degradation_start_hour * 3600 * self.sampling_rate_hz
                )
                if i >= degrad_start_sample:
                    cooling_rate *= degradation_factor

            # Newton's cooling law
            temp_diff = temp - 20.0  # Ambient ~20C
            cooling = cooling_rate * temp_diff

            # Temperature update
            temp_change = (heat - cooling) * self.dt
            temp = np.clip(temp + temp_change, 20.0, max_temp)

            payload_temp[i] = temp + np.random.normal(0, 0.2)

        return payload_temp

    def simulate_bus_current(
        self,
        battery_charge: np.ndarray,
        battery_voltage: np.ndarray,
        base_current: float = 20.0,
    ) -> np.ndarray:
        """
        Simulate bus current draw.

        Why bus current matters:
        1. Current is proxy for power dissipation rate (heat)
        2. Increases when battery voltage sags (regulation effort)
        3. Increases when battery state of charge is low (higher internal resistance)
        4. Directly observable in telemetry
        5. Can diagnose power subsystem stress

        Args:
            battery_charge: Battery state of charge
            battery_voltage: Battery output voltage
            base_current: Nominal bus current

        Returns:
            bus_current: Current time series
        """
        
        # Current stress from low state of charge
        charge_stress = 1.0 - battery_charge / 100.0
        
        # Current stress from voltage sag (regulator working harder)
        voltage_stress = 1.0 - battery_voltage / 28.0

        # Total current combines both stresses
        current = base_current * (1.0 + 0.5 * charge_stress + 0.3 * voltage_stress)
        
        # Add sensor noise
        current += np.random.normal(0, 1, len(current))
        
        # Physical limits on current (can't go below 5A, above 50A)
        current = np.clip(current, 5, 50)

        return current

    def run_nominal(
        self,
        solar_input: np.ndarray,
        battery_charge: np.ndarray,
        battery_voltage: np.ndarray,
    ) -> ThermalTelemetry:
        """
        Simulate healthy (nominal) thermal subsystem.
        
        Takes power subsystem data as input because thermal effects depend on
        power dissipation (charging currents, loads, regulation losses).
        """
        
        panel_temp = self.simulate_solar_panel_temp(degradation_start_hour=None)
        batt_temp = self.simulate_battery_temp(
            solar_input, battery_charge, degradation_start_hour=None
        )
        payload_temp = self.simulate_payload_temp(
            battery_voltage, degradation_start_hour=None
        )
        bus_current = self.simulate_bus_current(battery_charge, battery_voltage)

        return ThermalTelemetry(
            time=self.time,
            battery_temp=batt_temp,
            solar_panel_temp=panel_temp,
            payload_temp=payload_temp,
            bus_current=bus_current,
            timestamp=np.arange(self.num_samples),
        )

    def run_degraded(
        self,
        solar_input: np.ndarray,
        battery_charge: np.ndarray,
        battery_voltage: np.ndarray,
        panel_degradation_hour: float = 6.0,
        panel_drift_rate: float = 0.6,
        battery_cooling_hour: float = 8.0,
        battery_cooling_factor: float = 0.5,
        payload_cooling_hour: float = None,
        payload_cooling_factor: float = 0.7,
    ) -> ThermalTelemetry:
        """
        Simulate degraded thermal subsystem with realistic failure modes.
        
        Multi-fault thermal scenarios:
        - Panel insulation loss: temperature drifts upward, uncontrolled
        - Heatsink failure: battery temperature spikes when charging
        - Radiator fouling: payload can't dissipate heat efficiently
        
        These independent failures can cascade when combined with power faults
        (e.g., solar loss reduces charging current, helping battery cool,
        but battery aging increases I^2R losses, offsetting the benefit).
        """
        
        panel_temp = self.simulate_solar_panel_temp(
            degradation_start_hour=panel_degradation_hour,
            degradation_drift_rate=panel_drift_rate,
        )
        batt_temp = self.simulate_battery_temp(
            solar_input,
            battery_charge,
            degradation_start_hour=battery_cooling_hour,
            degradation_factor=battery_cooling_factor,
        )
        payload_temp = self.simulate_payload_temp(
            battery_voltage,
            degradation_start_hour=payload_cooling_hour,
            degradation_factor=payload_cooling_factor,
        )
        bus_current = self.simulate_bus_current(battery_charge, battery_voltage)

        return ThermalTelemetry(
            time=self.time,
            battery_temp=batt_temp,
            solar_panel_temp=panel_temp,
            payload_temp=payload_temp,
            bus_current=bus_current,
            timestamp=np.arange(self.num_samples),
        )


if __name__ == "__main__":
    # Quick test of thermal simulator
    from simulator.power import PowerSimulator

    power_sim = PowerSimulator(duration_hours=24)
    power_nominal = power_sim.run_nominal()

    thermal_sim = ThermalSimulator(duration_hours=24)

    print("Simulating nominal thermal scenario...")
    thermal_nominal = thermal_sim.run_nominal(
        power_nominal.solar_input,
        power_nominal.battery_charge,
        power_nominal.battery_voltage,
    )
    print(
        f"  Battery: {thermal_nominal.battery_temp.mean():.1f}C (mean), "
        f"Panel: {thermal_nominal.solar_panel_temp.mean():.1f}C (mean)"
    )

    print("Simulating degraded thermal scenario...")
    thermal_degraded = thermal_sim.run_degraded(
        power_nominal.solar_input,
        power_nominal.battery_charge,
        power_nominal.battery_voltage,
        panel_degradation_hour=6.0,
        battery_cooling_hour=8.0,
    )
    print(
        f"  Battery: {thermal_degraded.battery_temp.mean():.1f}C (mean), "
        f"Panel: {thermal_degraded.solar_panel_temp.mean():.1f}C (mean)"
    )
